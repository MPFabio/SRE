apiVersion: apps/v1
kind: Deployment
metadata:
  name: postmortem-flask
  labels:
    app: postmortem-flask
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postmortem-flask
  template:
    metadata:
      labels:
        app: postmortem-flask
    spec:
      containers:
      - name: postmortem-flask
        image: python:3.11-slim
        ports:
        - containerPort: 5000
        command: ["/bin/bash"]
        args:
        - -c
        - |
          # Installer les dépendances
          pip install --no-cache-dir flask markdown
          
          # Créer les répertoires
          mkdir -p /app/data/postmortems
          mkdir -p /app/templates
          
          # Copier l'application Flask EXACTE de votre app locale
          cat > /app/app.py << 'EOF'
          #!/usr/bin/env python3
          """
          Application Flask pour la présentation des post-mortems SRE
          Interface web pour visualiser les post-mortems avec un format structuré
          """

          from flask import Flask, render_template, jsonify, request
          import json
          import os
          from datetime import datetime
          import logging

          # Configuration du logging
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)

          app = Flask(__name__)

          # Configuration
          POSTMORTEM_DIR = "data/postmortems"
          TEMPLATE_DIR = "templates"

          def load_postmortem(postmortem_id):
              """Charge un post-mortem depuis le fichier JSON"""
              try:
                  file_path = os.path.join(POSTMORTEM_DIR, f"{postmortem_id}.json")
                  with open(file_path, 'r', encoding='utf-8') as f:
                      return json.load(f)
              except FileNotFoundError:
                  logger.error(f"Post-mortem {postmortem_id} non trouvé")
                  return None
              except json.JSONDecodeError as e:
                  logger.error(f"Erreur de parsing JSON pour {postmortem_id}: {e}")
                  return None

          def list_postmortems():
              """Liste tous les post-mortems disponibles"""
              postmortems = []
              if os.path.exists(POSTMORTEM_DIR):
                  for filename in os.listdir(POSTMORTEM_DIR):
                      if filename.endswith('.json'):
                          postmortem_id = filename[:-5]  # Enlever .json
                          try:
                              postmortem = load_postmortem(postmortem_id)
                              if postmortem:
                                  postmortems.append({
                                      'id': postmortem_id,
                                      'title': postmortem.get('title', 'Sans titre'),
                                      'incident_date': postmortem.get('incident_date', ''),
                                      'status': postmortem.get('status', 'Brouillon'),
                                      'published': postmortem.get('published', '')
                                  })
                          except Exception as e:
                              logger.error(f"Erreur lors du chargement de {postmortem_id}: {e}")
              return sorted(postmortems, key=lambda x: x.get('incident_date', ''), reverse=True)

          @app.route('/')
          def index():
              """Page d'accueil avec la liste des post-mortems"""
              postmortems = list_postmortems()
              return render_template('index.html', postmortems=postmortems)

          @app.route('/postmortem/<postmortem_id>')
          def view_postmortem(postmortem_id):
              """Page de visualisation d'un post-mortem spécifique"""
              postmortem = load_postmortem(postmortem_id)
              if not postmortem:
                  return render_template('error.html', 
                                       message=f"Post-mortem '{postmortem_id}' non trouvé"), 404
              
              return render_template('postmortem.html', postmortem=postmortem)

          @app.route('/api/postmortems')
          def api_list_postmortems():
              """API pour lister les post-mortems"""
              postmortems = list_postmortems()
              return jsonify(postmortems)

          @app.route('/api/postmortem/<postmortem_id>')
          def api_get_postmortem(postmortem_id):
              """API pour récupérer un post-mortem spécifique"""
              postmortem = load_postmortem(postmortem_id)
              if not postmortem:
                  return jsonify({'error': 'Post-mortem non trouvé'}), 404
              return jsonify(postmortem)

          @app.route('/create')
          def create_postmortem():
              """Page de création d'un nouveau post-mortem"""
              return render_template('create.html')

          @app.route('/api/create', methods=['POST'])
          def api_create_postmortem():
              """API pour créer un nouveau post-mortem"""
              try:
                  data = request.get_json()
                  
                  # Générer un ID unique basé sur le timestamp
                  postmortem_id = f"incident_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                  
                  # Ajouter des métadonnées
                  data['created_at'] = datetime.now().isoformat()
                  data['id'] = postmortem_id
                  
                  # Sauvegarder le fichier
                  os.makedirs(POSTMORTEM_DIR, exist_ok=True)
                  file_path = os.path.join(POSTMORTEM_DIR, f"{postmortem_id}.json")
                  
                  with open(file_path, 'w', encoding='utf-8') as f:
                      json.dump(data, f, indent=2, ensure_ascii=False)
                  
                  return jsonify({'success': True, 'id': postmortem_id})
              
              except Exception as e:
                  logger.error(f"Erreur lors de la création du post-mortem: {e}")
                  return jsonify({'error': str(e)}), 500

          @app.errorhandler(404)
          def not_found(error):
              return render_template('error.html', message="Page non trouvée"), 404

          @app.errorhandler(500)
          def internal_error(error):
              return render_template('error.html', message="Erreur interne du serveur"), 500

          if __name__ == '__main__':
              # Créer les répertoires nécessaires
              os.makedirs(POSTMORTEM_DIR, exist_ok=True)
              os.makedirs(TEMPLATE_DIR, exist_ok=True)
              
              # Démarrer l'application
              app.run(host='0.0.0.0', port=5000, debug=True)
          EOF
          
          # Copier les templates EXACTS de votre app locale
          cat > /app/templates/base.html << 'EOF'
          <!DOCTYPE html>
          <html lang="fr">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>{% block title %}Post-Mortems SRE{% endblock %}</title>
              <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
              <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
              <style>
                  .navbar-brand { font-weight: bold; }
                  .card { margin-bottom: 1rem; }
                  .badge { font-size: 0.8em; }
                  .timeline-item { margin-bottom: 1rem; }
                  .action-item { margin-bottom: 0.5rem; }
              </style>
          </head>
          <body>
              <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
                  <div class="container">
                      <a class="navbar-brand" href="{{ url_for('index') }}">
                          <i class="fas fa-clipboard-list me-2"></i>Post-Mortems SRE
                      </a>
                      <div class="navbar-nav ms-auto">
                          <a class="nav-link" href="{{ url_for('index') }}">
                              <i class="fas fa-list me-1"></i>Liste
                          </a>
                          <a class="nav-link" href="{{ url_for('create_postmortem') }}">
                              <i class="fas fa-plus me-1"></i>Créer
                          </a>
                      </div>
                  </div>
              </nav>

              <main>
                  {% block content %}{% endblock %}
              </main>

              <footer class="bg-dark text-light py-3 mt-5">
                  <div class="container">
                      <div class="row">
                          <div class="col-md-6">
                              <h5>Post-Mortems SRE</h5>
                              <p class="mb-0">Interface de gestion et visualisation des post-mortems d'incidents.</p>
                          </div>
                          <div class="col-md-6 text-md-end">
                              <p class="mb-0">© 2024 Lab SRE. Tous droits réservés.</p>
                          </div>
                      </div>
                  </div>
              </footer>

              <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
          </body>
          </html>
          EOF
          
          # Copier index.html EXACT de votre app locale
          cat > /app/templates/index.html << 'EOF'
          {% extends "base.html" %}

          {% block title %}Liste des Post-Mortems - SRE{% endblock %}

          {% block content %}
          <div class="container mt-4">
              <!-- En-tête -->
              <div class="row mb-4">
                  <div class="col-12">
                      <h1 class="display-4 text-center mb-3">
                          <i class="fas fa-clipboard-list text-primary me-3"></i>
                          Post-Mortems SRE
                      </h1>
                      <p class="lead text-center text-muted">
                          Gestion et visualisation des post-mortems d'incidents
                      </p>
                  </div>
              </div>

              <!-- Statistiques -->
              <div class="row mb-4">
                  <div class="col-md-3">
                      <div class="card text-center">
                          <div class="card-body">
                              <h3 class="text-primary">{{ postmortems|length }}</h3>
                              <p class="text-muted">Total Post-Mortems</p>
                          </div>
                      </div>
                  </div>
                  <div class="col-md-3">
                      <div class="card text-center">
                          <div class="card-body">
                              <h3 class="text-success">{{ postmortems|selectattr('status', 'equalto', 'Final')|list|length }}</h3>
                              <p class="text-muted">Finalisés</p>
                          </div>
                      </div>
                  </div>
                  <div class="col-md-3">
                      <div class="card text-center">
                          <div class="card-body">
                              <h3 class="text-warning">{{ postmortems|selectattr('status', 'equalto', 'Brouillon')|list|length }}</h3>
                              <p class="text-muted">Brouillons</p>
                          </div>
                      </div>
                  </div>
                  <div class="col-md-3">
                      <div class="card text-center">
                          <div class="card-body">
                              <h3 class="text-info">{{ postmortems|selectattr('status', 'equalto', 'En cours de révision')|list|length }}</h3>
                              <p class="text-muted">En Révision</p>
                          </div>
                      </div>
                  </div>
              </div>

              <!-- Bouton de création -->
              <div class="row mb-4">
                  <div class="col-12 text-center">
                      <a href="{{ url_for('create_postmortem') }}" class="btn btn-primary btn-lg">
                          <i class="fas fa-plus me-2"></i>Nouveau Post-Mortem
                      </a>
                  </div>
              </div>

              <!-- Liste des post-mortems -->
              <div class="row">
                  {% for postmortem in postmortems %}
                  <div class="col-md-4 mb-4">
                      <div class="card h-100">
                          <div class="card-header d-flex justify-content-between align-items-center">
                              <h6 class="mb-0">{{ postmortem.owner }}</h6>
                              <span class="badge bg-success">{{ postmortem.status }}</span>
                          </div>
                          <div class="card-body">
                              <h5 class="card-title">{{ postmortem.title }}</h5>
                              <p class="card-text">
                                  <small class="text-muted">
                                      <i class="fas fa-calendar me-1"></i>
                                      {{ postmortem.incident_date[:10] if postmortem.incident_date else 'Date inconnue' }}
                                  </small>
                              </p>
                              {% if postmortem.problem_summary.duration %}
                              <p class="card-text">
                                  <small class="text-muted">
                                      <i class="fas fa-clock me-1"></i>
                                      Durée: {{ postmortem.problem_summary.duration }}
                                  </small>
                              </p>
                              {% endif %}
                              {% if postmortem.executive_summary.impact %}
                              <p class="card-text">
                                  <small class="text-muted">{{ postmortem.executive_summary.impact[:100] }}...</small>
                              </p>
                              {% endif %}
                          </div>
                          <div class="card-footer">
                              <a href="{{ url_for('view_postmortem', postmortem_id=postmortem.id) }}" class="btn btn-primary btn-sm">
                                  <i class="fas fa-eye me-1"></i>Voir
                              </a>
                          </div>
                      </div>
                  </div>
                  {% endfor %}
              </div>

              {% if not postmortems %}
              <div class="row">
                  <div class="col-12 text-center">
                      <div class="alert alert-info">
                          <i class="fas fa-info-circle me-2"></i>
                          Aucun post-mortem trouvé. 
                          <a href="{{ url_for('create_postmortem') }}" class="alert-link">Créer le premier post-mortem</a>.
                      </div>
                  </div>
              </div>
              {% endif %}
          </div>
          {% endblock %}
          EOF
          
          # Copier les autres templates EXACTS
          cat > /app/templates/error.html << 'EOF'
          {% extends "base.html" %}

          {% block title %}Erreur - Post-Mortems SRE{% endblock %}

          {% block content %}
          <div class="container mt-5">
              <div class="row justify-content-center">
                  <div class="col-md-6">
                      <div class="alert alert-danger text-center">
                          <i class="fas fa-exclamation-triangle fa-3x mb-3"></i>
                          <h4>Erreur</h4>
                          <p>{{ message }}</p>
                          <a href="{{ url_for('index') }}" class="btn btn-primary">
                              <i class="fas fa-home me-1"></i>Retour à l'accueil
                          </a>
                      </div>
                  </div>
              </div>
          </div>
          {% endblock %}
          EOF
          
          cat > /app/templates/postmortem.html << 'EOF'
          {% extends "base.html" %}

          {% block title %}{{ postmortem.title }} - Post-Mortems SRE{% endblock %}

          {% block content %}
          <div class="container mt-4">
              <div class="row">
                  <div class="col-12">
                      <div class="d-flex justify-content-between align-items-center mb-4">
                          <h1>{{ postmortem.title }}</h1>
                          <span class="badge bg-success fs-6">{{ postmortem.status }}</span>
                      </div>
                      
                      <div class="card">
                          <div class="card-header">
                              <h5 class="mb-0">Informations générales</h5>
                          </div>
                          <div class="card-body">
                              <div class="row">
                                  <div class="col-md-6">
                                      <p><strong>Propriétaire:</strong> {{ postmortem.owner }}</p>
                                      <p><strong>Date de l'incident:</strong> {{ postmortem.incident_date }}</p>
                                  </div>
                                  <div class="col-md-6">
                                      <p><strong>Publié:</strong> {{ postmortem.published }}</p>
                                      <p><strong>Partagé avec:</strong> {{ postmortem.shared_with }}</p>
                                  </div>
                              </div>
                          </div>
                      </div>
                      
                      {% if postmortem.executive_summary %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Résumé exécutif</h5>
                          </div>
                          <div class="card-body">
                              <p><strong>Impact:</strong> {{ postmortem.executive_summary.impact }}</p>
                              <p><strong>Cause racine:</strong> {{ postmortem.executive_summary.root_cause }}</p>
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.problem_summary %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Résumé du problème</h5>
                          </div>
                          <div class="card-body">
                              <div class="row">
                                  <div class="col-md-6">
                                      <p><strong>Durée:</strong> {{ postmortem.problem_summary.duration }}</p>
                                      <p><strong>Début:</strong> {{ postmortem.problem_summary.start_time }}</p>
                                  </div>
                                  <div class="col-md-6">
                                      <p><strong>Fin:</strong> {{ postmortem.problem_summary.end_time }}</p>
                                      <p><strong>Produits affectés:</strong> {{ postmortem.problem_summary.products_affected }}</p>
                                  </div>
                              </div>
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.impact %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Impact détaillé</h5>
                          </div>
                          <div class="card-body">
                              {% if postmortem.impact.user_impact %}
                              <h6>Impact utilisateur</h6>
                              <p><strong>Requêtes perdues:</strong> {{ postmortem.impact.user_impact.requests_lost }}</p>
                              <p><strong>Source des données:</strong> {{ postmortem.impact.user_impact.data_source }}</p>
                              {% endif %}
                              
                              {% if postmortem.impact.revenue_impact %}
                              <h6>Impact financier</h6>
                              <p><strong>Perte de revenus:</strong> {{ postmortem.impact.revenue_impact.revenue_loss }}</p>
                              <p><strong>Période:</strong> {{ postmortem.impact.revenue_impact.revenue_period }}</p>
                              {% endif %}
                              
                              {% if postmortem.impact.team_impact %}
                              <h6>Impact équipe</h6>
                              <p><strong>Heures équipe:</strong> {{ postmortem.impact.team_impact.team_hours }}</p>
                              <p><strong>Support client:</strong> {{ postmortem.impact.team_impact.customer_support }}</p>
                              {% endif %}
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.root_causes %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Causes racines</h5>
                          </div>
                          <div class="card-body">
                              <p><strong>Cause technique:</strong> {{ postmortem.root_causes.technical_cause }}</p>
                              <p><strong>Déclencheur:</strong> {{ postmortem.root_causes.trigger }}</p>
                              <p><strong>Réaction système:</strong> {{ postmortem.root_causes.system_reaction }}</p>
                              <p><strong>Protections manquantes:</strong> {{ postmortem.root_causes.missing_protections }}</p>
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.timeline %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Timeline de l'incident</h5>
                          </div>
                          <div class="card-body">
                              {% for event in postmortem.timeline %}
                              <div class="timeline-item">
                                  <div class="d-flex">
                                      <div class="me-3">
                                          <span class="badge bg-primary">{{ event.time }}</span>
                                      </div>
                                      <div>
                                          <h6 class="mb-1">{{ event.title }}</h6>
                                          <p class="mb-0 text-muted">{{ event.description }}</p>
                                      </div>
                                  </div>
                              </div>
                              {% endfor %}
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.lessons_learned %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Leçons apprises</h5>
                          </div>
                          <div class="card-body">
                              {% if postmortem.lessons_learned.things_that_went_well %}
                              <h6>Ce qui s'est bien passé</h6>
                              <ul>
                                  {% for item in postmortem.lessons_learned.things_that_went_well %}
                                  <li>{{ item }}</li>
                                  {% endfor %}
                              </ul>
                              {% endif %}
                              
                              {% if postmortem.lessons_learned.things_that_went_poorly %}
                              <h6>Ce qui s'est mal passé</h6>
                              {% if postmortem.lessons_learned.things_that_went_poorly.outage %}
                              <p><strong>Pendant la panne:</strong></p>
                              <ul>
                                  {% for item in postmortem.lessons_learned.things_that_went_poorly.outage %}
                                  <li>{{ item }}</li>
                                  {% endfor %}
                              </ul>
                              {% endif %}
                              {% if postmortem.lessons_learned.things_that_went_poorly.recovery %}
                              <p><strong>Pendant la récupération:</strong></p>
                              <ul>
                                  {% for item in postmortem.lessons_learned.things_that_went_poorly.recovery %}
                                  <li>{{ item }}</li>
                                  {% endfor %}
                              </ul>
                              {% endif %}
                              {% endif %}
                              
                              {% if postmortem.lessons_learned.where_we_got_lucky %}
                              <h6>Où nous avons eu de la chance</h6>
                              <ul>
                                  {% for item in postmortem.lessons_learned.where_we_got_lucky %}
                                  <li>{{ item }}</li>
                                  {% endfor %}
                              </ul>
                              {% endif %}
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.action_items %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Actions à suivre</h5>
                          </div>
                          <div class="card-body">
                              {% for action in postmortem.action_items %}
                              <div class="action-item">
                                  <div class="d-flex justify-content-between align-items-start">
                                      <div class="flex-grow-1">
                                          <p class="mb-1"><strong>{{ action.description }}</strong></p>
                                          <small class="text-muted">
                                              Type: {{ action.type }} | 
                                              Priorité: {{ action.priority }} | 
                                              Responsable: {{ action.owner }}
                                          </small>
                                      </div>
                                      <span class="badge bg-secondary">{{ action.tracking_bug }}</span>
                                  </div>
                              </div>
                              {% endfor %}
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.glossary %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Glossaire</h5>
                          </div>
                          <div class="card-body">
                              {% for term, definition in postmortem.glossary.items() %}
                              <p><strong>{{ term }}:</strong> {{ definition }}</p>
                              {% endfor %}
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.appendix %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Annexe</h5>
                          </div>
                          <div class="card-body">
                              <p>{{ postmortem.appendix }}</p>
                          </div>
                      </div>
                      {% endif %}
                  </div>
              </div>
          </div>
          {% endblock %}
          EOF
          
          cat > /app/templates/create.html << 'EOF'
          {% extends "base.html" %}

          {% block title %}Créer un Post-Mortem - SRE{% endblock %}

          {% block content %}
          <div class="container mt-4">
              <div class="row">
                  <div class="col-12">
                      <h1>Créer un nouveau Post-Mortem</h1>
                      <p class="text-muted">Formulaire de création d'un post-mortem d'incident</p>
                  </div>
              </div>
              
              <div class="row">
                  <div class="col-md-8">
                      <div class="card">
                          <div class="card-body">
                              <form id="postmortemForm">
                                  <div class="mb-3">
                                      <label for="title" class="form-label">Titre *</label>
                                      <input type="text" class="form-control" id="title" name="title" required>
                                  </div>
                                  
                                  <div class="mb-3">
                                      <label for="owner" class="form-label">Propriétaire *</label>
                                      <input type="text" class="form-control" id="owner" name="owner" required>
                                  </div>
                                  
                                  <div class="mb-3">
                                      <label for="incident_date" class="form-label">Date de l'incident *</label>
                                      <input type="datetime-local" class="form-control" id="incident_date" name="incident_date" required>
                                  </div>
                                  
                                  <div class="mb-3">
                                      <label for="status" class="form-label">Statut</label>
                                      <select class="form-select" id="status" name="status">
                                          <option value="Brouillon">Brouillon</option>
                                          <option value="En cours de révision">En cours de révision</option>
                                          <option value="Final">Final</option>
                                      </select>
                                  </div>
                                  
                                  <button type="submit" class="btn btn-primary">
                                      <i class="fas fa-save me-1"></i>Créer le Post-Mortem
                                  </button>
                              </form>
                          </div>
                      </div>
                  </div>
              </div>
          </div>

          <script>
          document.getElementById('postmortemForm').addEventListener('submit', async function(e) {
              e.preventDefault();
              
              const formData = new FormData(this);
              const data = Object.fromEntries(formData.entries());
              
              try {
                  const response = await fetch('/api/create', {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                      },
                      body: JSON.stringify(data)
                  });
                  
                  const result = await response.json();
                  
                  if (result.success) {
                      alert('Post-mortem créé avec succès !');
                      window.location.href = '/';
                  } else {
                      alert('Erreur lors de la création: ' + result.error);
                  }
              } catch (error) {
                  alert('Erreur réseau: ' + error.message);
              }
          });
          </script>
          {% endblock %}
          EOF
          
          # Copier les post-mortems EXACTS de votre app locale
          cat > /app/data/postmortems/incident_20241210_163000.json << 'EOF'
          {
            "id": "incident_20241210_163000",
            "title": "Panne du service d'authentification - Indisponibilité des connexions utilisateurs",
            "owner": "Équipe Security",
            "shared_with": "Équipes Engineering, Product, Support, Legal",
            "status": "Final",
            "incident_date": "2024-12-10T16:30:00Z",
            "published": "2024-12-11",
            "created_at": "2024-12-10T18:45:00Z",
            "executive_summary": {
              "impact": "L'incident a rendu impossible toute connexion utilisateur pendant 3h15, affectant 25 000 utilisateurs actifs et bloquant l'accès à tous les services nécessitant une authentification.",
              "root_cause": "Une panne du service d'authentification OAuth2 due à l'expiration d'un certificat SSL critique qui n'était pas surveillé."
            },
            "problem_summary": {
              "duration": "3h15",
              "start_time": "2024-12-10T16:30:00Z",
              "end_time": "2024-12-10T19:45:00Z",
              "residual_effects": "2024-12-10T20:00:00Z - Latence élevée pendant 15 minutes supplémentaires",
              "products_affected": "Service d'authentification OAuth2, API Gateway, Applications web et mobile",
              "percentage_affected": "100% des utilisateurs nécessitant une authentification",
              "user_impact": "25 000 utilisateurs actifs ont été bloqués, impossible de se connecter à tous les services",
              "revenue_impact": "Perte estimée de 8 500€ due à l'impossibilité d'accéder aux services payants et aux conversions",
              "detection": "Alertes automatiques sur le taux d'erreur d'authentification > 99%",
              "resolution": "Renouvellement du certificat SSL, redémarrage du service d'authentification, et validation de tous les flux d'authentification."
            },
            "impact": {
              "user_impact": {
                "requests_lost": "75 000 tentatives de connexion échouées",
                "data_source": "Logs d'authentification et métriques de l'API Gateway",
                "additional_symptoms": "Erreurs 500 sur toutes les tentatives de connexion, timeouts sur les requêtes d'authentification, saturation des logs d'erreur"
              },
              "revenue_impact": {
                "revenue_loss": "8 500€, principalement sur les services payants et les conversions",
                "revenue_period": "16:30 - 19:45 (3h15)",
                "indirect_impacts": "Perte de confiance des utilisateurs, 12 annulations d'abonnements, impact sur la réputation de sécurité"
              },
              "team_impact": {
                "team_hours": "12 heures à la résolution, investigation et communication",
                "customer_support": "Support client avec 340 tickets créés et 89 appels téléphoniques",
                "secondary_effects": "Surcharge du support client, stress des équipes de sécurité, impact sur la réputation"
              }
            },
            "root_causes": {
              "technical_cause": "Le certificat SSL du service d'authentification OAuth2 a expiré à 16:30, rendant impossible la validation des tokens et bloquant tous les flux d'authentification.",
              "trigger": "L'expiration automatique du certificat SSL à 16:30 a immédiatement cassé toutes les communications sécurisées du service d'authentification.",
              "system_reaction": "Le service d'authentification a commencé à rejeter toutes les requêtes avec des erreurs SSL, empêchant la validation des tokens et bloquant l'accès aux services.",
              "non_idempotent_operation": "Le renouvellement de certificat n'était pas automatisé et nécessitait une intervention manuelle avec redémarrage du service.",
              "missing_protections": "Absence de monitoring des certificats SSL, pas d'alerte avant expiration, absence de renouvellement automatique, pas de certificats de backup.",
              "late_detection": "Aucune surveillance des certificats SSL n'était en place, et les équipes comptaient sur les notifications manuelles du fournisseur de certificats."
            },
            "timeline": [
              {
                "time": "16:30",
                "title": "Expiration du certificat SSL",
                "description": "Le certificat SSL du service d'authentification expire automatiquement"
              },
              {
                "time": "16:32",
                "title": "Détection automatique de l'incident",
                "description": "Alertes déclenchées sur le taux d'erreur d'authentification > 99%"
              },
              {
                "time": "16:35",
                "title": "Mobilisation de l'équipe Security",
                "description": "Équipe Security et Engineering mobilisées, début de l'investigation"
              },
              {
                "time": "16:45",
                "title": "Identification de la cause",
                "description": "Découverte de l'expiration du certificat SSL et des erreurs de validation"
              },
              {
                "time": "17:00",
                "title": "Communication externe",
                "description": "Publication d'un message de statut et notification des utilisateurs"
              },
              {
                "time": "17:30",
                "title": "Début du renouvellement",
                "description": "Début du processus de renouvellement du certificat SSL"
              },
              {
                "time": "19:00",
                "title": "Installation du nouveau certificat",
                "description": "Installation et configuration du nouveau certificat SSL"
              },
              {
                "time": "19:30",
                "title": "Redémarrage du service",
                "description": "Redémarrage du service d'authentification avec le nouveau certificat"
              },
              {
                "time": "19:45",
                "title": "Validation et résolution",
                "description": "Test de tous les flux d'authentification et validation du fonctionnement"
              }
            ],
            "lessons_learned": {
              "things_that_went_well": [
                "Les alertes automatiques ont détecté l'incident en 2 minutes",
                "La communication avec les utilisateurs a été rapide et claire",
                "Le processus de renouvellement de certificat était documenté",
                "Aucune donnée utilisateur n'a été compromise"
              ],
              "things_that_went_poorly": {
                "outage": [
                  "Absence totale de monitoring des certificats SSL",
                  "Pas d'alerte avant expiration des certificats",
                  "Absence de renouvellement automatique",
                  "Pas de certificats de backup ou de rotation"
                ],
                "recovery": [
                  "Le processus de renouvellement a pris 2h30 (trop long)",
                  "Pas de procédure d'urgence pour les certificats expirés",
                  "Communication tardive avec les utilisateurs (30 minutes)",
                  "Absence de tests automatisés des flux d'authentification"
                ]
              },
              "where_we_got_lucky": [
                "Le certificat a expiré en journée (pas la nuit)",
                "Aucune tentative d'intrusion pendant la panne",
                "Les données utilisateur n'ont pas été compromises",
                "Le fournisseur de certificats a répondu rapidement"
              ]
            },
            "action_items": [
              {
                "description": "Implémenter un monitoring automatique des certificats SSL avec alertes 30 jours avant expiration",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe Security",
                "tracking_bug": "SEC-401"
              },
              {
                "description": "Configurer le renouvellement automatique des certificats SSL",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe Security",
                "tracking_bug": "SEC-402"
              },
              {
                "description": "Mettre en place une rotation automatique des certificats",
                "type": "prevent",
                "priority": "P1",
                "owner": "Équipe Security",
                "tracking_bug": "SEC-403"
              },
              {
                "description": "Créer des procédures d'urgence pour les incidents de certificats",
                "type": "remediate",
                "priority": "P1",
                "owner": "Équipe Security",
                "tracking_bug": "SEC-404"
              },
              {
                "description": "Améliorer la communication automatique en cas d'incident de sécurité",
                "type": "remediate",
                "priority": "P2",
                "owner": "Équipe Product",
                "tracking_bug": "PROD-501"
              }
            ],
            "glossary": {
              "OAuth2": "Protocole d'autorisation standard pour l'authentification et l'autorisation",
              "SSL": "Secure Sockets Layer, protocole de sécurité pour les communications chiffrées",
              "Token": "Jeton d'authentification utilisé pour valider l'identité d'un utilisateur",
              "API Gateway": "Point d'entrée unique pour toutes les requêtes API",
              "Certificat SSL": "Certificat numérique utilisé pour sécuriser les communications HTTPS"
            },
            "appendix": "Logs détaillés des erreurs SSL, métriques de l'API Gateway, captures d'écran des erreurs d'authentification, et documentation du processus de renouvellement de certificat."
          }
          EOF
          
          cat > /app/data/postmortems/incident_20241215_091500.json << 'EOF'
          {
            "id": "incident_20241215_091500",
            "title": "Panne du service de monitoring - Perte de visibilité sur l'infrastructure",
            "owner": "Équipe DevOps",
            "shared_with": "Équipes SRE, Engineering, Management",
            "status": "Final",
            "incident_date": "2024-12-15T09:15:00Z",
            "published": "2024-12-16",
            "created_at": "2024-12-15T11:30:00Z",
            "executive_summary": {
              "impact": "L'incident a causé une perte complète de visibilité sur l'infrastructure pendant 1h45, empêchant la détection proactive des problèmes et la surveillance des services critiques.",
              "root_cause": "Une mise à jour automatique de Prometheus a échoué silencieusement, provoquant un crash du service de monitoring sans déclencher d'alertes."
            },
            "problem_summary": {
              "duration": "1h45",
              "start_time": "2024-12-15T09:15:00Z",
              "end_time": "2024-12-15T11:00:00Z",
              "residual_effects": "2024-12-15T11:30:00Z - Métriques manquantes pour la période d'incident",
              "products_affected": "Prometheus, Grafana, AlertManager, Dashboards de monitoring",
              "percentage_affected": "100% du système de monitoring",
              "user_impact": "Perte de visibilité sur l'état de l'infrastructure, impossibilité de détecter les problèmes en temps réel",
              "revenue_impact": "Impact indirect estimé à 1 200€ due à la perte de visibilité sur les services critiques",
              "detection": "Détection manuelle par un ingénieur qui a remarqué l'absence de métriques dans Grafana",
              "resolution": "Redémarrage manuel de Prometheus, restauration de la configuration, et re-synchronisation des métriques."
            },
            "impact": {
              "user_impact": {
                "requests_lost": "N/A - Service de monitoring",
                "data_source": "Logs système et métriques de santé des services",
                "additional_symptoms": "Dashboards Grafana vides, absence d'alertes, métriques manquantes sur tous les services"
              },
              "revenue_impact": {
                "revenue_loss": "1 200€, principalement sur la perte de visibilité des services critiques",
                "revenue_period": "09:15 - 11:00 (1h45)",
                "indirect_impacts": "Risque accru de non-détection de problèmes critiques, impact sur la confiance des équipes"
              },
              "team_impact": {
                "team_hours": "6 heures à la résolution et investigation",
                "customer_support": "N/A - Service interne",
                "secondary_effects": "Stress accru des équipes sans visibilité, retard dans la détection d'autres problèmes potentiels"
              }
            },
            "root_causes": {
              "technical_cause": "La mise à jour automatique de Prometheus 2.45.0 vers 2.46.0 a échoué à cause d'un conflit de dépendances avec les plugins personnalisés, provoquant un crash silencieux du service.",
              "trigger": "Le système de mise à jour automatique a tenté d'installer la nouvelle version à 09:15, mais le processus s'est arrêté sans notification d'erreur.",
              "system_reaction": "Prometheus a cessé de collecter les métriques et de répondre aux requêtes, mais le processus est resté actif sans logs d'erreur visibles.",
              "non_idempotent_operation": "La mise à jour n'était pas idempotente car elle modifiait la configuration sans sauvegarde de l'état précédent.",
              "missing_protections": "Absence de monitoring du service de monitoring lui-même, pas de health checks sur Prometheus, absence de rollback automatique en cas d'échec.",
              "late_detection": "Aucune alerte n'a été configurée pour surveiller l'état de Prometheus lui-même, et les équipes comptaient sur la présence de métriques pour détecter les problèmes."
            },
            "timeline": [
              {
                "time": "09:15",
                "title": "Début de la mise à jour automatique",
                "description": "Système de mise à jour automatique lance l'installation de Prometheus 2.46.0"
              },
              {
                "time": "09:17",
                "title": "Échec silencieux de la mise à jour",
                "description": "Processus de mise à jour s'arrête sans notification, Prometheus cesse de fonctionner"
              },
              {
                "time": "10:30",
                "title": "Détection manuelle de l'incident",
                "description": "Ingénieur DevOps remarque l'absence de métriques dans Grafana"
              },
              {
                "time": "10:35",
                "title": "Investigation initiale",
                "description": "Vérification des logs et de l'état des services de monitoring"
              },
              {
                "time": "10:45",
                "title": "Identification de la cause",
                "description": "Découverte du crash de Prometheus et de l'échec de la mise à jour"
              },
              {
                "time": "10:50",
                "title": "Tentative de redémarrage",
                "description": "Redémarrage manuel de Prometheus (échec - configuration corrompue)"
              },
              {
                "time": "11:00",
                "title": "Restauration de la configuration",
                "description": "Restauration de la configuration précédente et redémarrage réussi"
              },
              {
                "time": "11:15",
                "title": "Re-synchronisation des métriques",
                "description": "Prometheus reprend la collecte des métriques historiques"
              },
              {
                "time": "11:30",
                "title": "Validation complète",
                "description": "Vérification que tous les dashboards et alertes fonctionnent correctement"
              }
            ],
            "lessons_learned": {
              "things_that_went_well": [
                "La détection manuelle a été rapide grâce à l'habitude des équipes de consulter les dashboards",
                "La configuration était sauvegardée et a pu être restaurée rapidement",
                "Aucune donnée de monitoring n'a été perdue définitivement"
              ],
              "things_that_went_poorly": {
                "outage": [
                  "Absence de monitoring du service de monitoring lui-même",
                  "Mise à jour automatique sans tests de validation",
                  "Pas de rollback automatique en cas d'échec",
                  "Absence de health checks sur Prometheus"
                ],
                "recovery": [
                  "Le redémarrage simple n'a pas suffi (configuration corrompue)",
                  "Pas de procédure documentée pour les incidents de monitoring",
                  "Temps de récupération plus long que nécessaire"
                ]
              },
              "where_we_got_lucky": [
                "La configuration était sauvegardée et non corrompue",
                "Aucun autre incident critique n'est survenu pendant la perte de visibilité",
                "Les équipes ont rapidement identifié le problème"
              ]
            },
            "action_items": [
              {
                "description": "Implémenter un monitoring du service de monitoring (Prometheus, Grafana, AlertManager)",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe DevOps",
                "tracking_bug": "DEV-201"
              },
              {
                "description": "Ajouter des tests de validation avant les mises à jour automatiques",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe DevOps",
                "tracking_bug": "DEV-202"
              },
              {
                "description": "Configurer un rollback automatique en cas d'échec de mise à jour",
                "type": "prevent",
                "priority": "P1",
                "owner": "Équipe DevOps",
                "tracking_bug": "DEV-203"
              },
              {
                "description": "Documenter les procédures de récupération des services de monitoring",
                "type": "remediate",
                "priority": "P1",
                "owner": "Équipe DevOps",
                "tracking_bug": "DEV-204"
              },
              {
                "description": "Mettre en place des health checks externes pour Prometheus",
                "type": "prevent",
                "priority": "P2",
                "owner": "Équipe SRE",
                "tracking_bug": "SRE-301"
              }
            ],
            "glossary": {
              "Prometheus": "Système de monitoring et d'alerting open source",
              "Grafana": "Plateforme de visualisation et de dashboards pour les métriques",
              "AlertManager": "Composant de Prometheus responsable de la gestion des alertes",
              "Health Check": "Vérification périodique de l'état de santé d'un service",
              "Rollback": "Retour à une version précédente stable en cas de problème"
            },
            "appendix": "Logs détaillés de la mise à jour Prometheus, captures d'écran des dashboards vides, et analyse des dépendances qui ont causé l'échec de la mise à jour."
          }
          EOF
          
          cat > /app/data/postmortems/incident_20241222_143000.json << 'EOF'
          {
            "id": "incident_20241222_143000",
            "title": "Panne du service URL Shortener - Saturation de la base de données",
            "owner": "Équipe SRE",
            "shared_with": "Équipes Engineering, Product, Support",
            "status": "Final",
            "incident_date": "2024-12-22T14:30:00Z",
            "published": "2024-12-23",
            "created_at": "2024-12-22T16:00:00Z",
            "executive_summary": {
              "impact": "L'incident a causé une indisponibilité complète du service URL Shortener pendant 2h30, affectant 15 000 utilisateurs actifs et générant 45 000 requêtes perdues.",
              "root_cause": "Une requête SQL mal optimisée a provoqué un verrouillage de table sur la base de données PostgreSQL, empêchant toute nouvelle connexion."
            },
            "problem_summary": {
              "duration": "2h30",
              "start_time": "2024-12-22T14:30:00Z",
              "end_time": "2024-12-22T17:00:00Z",
              "residual_effects": "2024-12-22T17:15:00Z - Latence élevée pendant 15 minutes supplémentaires",
              "products_affected": "Service URL Shortener, API de redirection, Dashboard admin",
              "percentage_affected": "100%",
              "user_impact": "15 000 utilisateurs actifs ont été affectés, avec 45 000 requêtes perdues et des erreurs 500 sur toutes les redirections d'URLs courtes.",
              "revenue_impact": "Perte estimée de 2 500€ due à la baisse de conversions et aux annulations d'abonnements premium.",
              "detection": "Alertes Prometheus sur le taux d'erreur HTTP 500 > 95% pendant 5 minutes consécutives",
              "resolution": "Redémarrage forcé du service PostgreSQL, rollback de la version précédente de l'application, et redéploiement avec correctif de la requête SQL."
            },
            "impact": {
              "user_impact": {
                "description": "L'incident a causé une indisponibilité complète du service URL Shortener, empêchant toute redirection d'URLs courtes.",
                "requests_lost": "45 000 requêtes perdues (100% du trafic normal)",
                "data_source": "Prometheus metrics et logs Nginx, fiabilité jugée fiable",
                "additional_symptoms": "Erreurs 500 sur toutes les redirections, timeout des requêtes après 30s, saturation des logs d'erreur"
              },
              "revenue_impact": {
                "description": "La perte de revenus estimée sur la période est de 2 500€, principalement sur les conversions premium et les abonnements.",
                "period": "14:30 - 17:00 (2h30)",
                "uncertainty": "±20% en raison des variations saisonnières",
                "indirect_impacts": "Baisse de 15% de la satisfaction client, 3 annulations d'abonnements premium, impact sur la réputation de la marque"
              },
              "team_impact": {
                "description": "Les équipes ont consacré environ 8 heures à la résolution de l'incident, incluant investigation, mitigation, communication et analyse post-mortem.",
                "customer_support": "Support client avec 127 tickets créés et 45 appels téléphoniques",
                "engineering_teams": "Équipes d'ingénierie mobilisées pour rollback, redéploiement, analyse des logs et correction du code",
                "secondary_effects": "Saturation du cache Redis, surcharge du load balancer, contention sur les connexions de base de données"
              }
            },
            "root_causes": {
              "technical_cause": "Une requête SQL dans la fonction de recherche d'URLs courtes utilisait un index manquant sur la colonne 'created_at', provoquant un scan complet de table sur 2M d'enregistrements.",
              "trigger": "Le déploiement de la version 2.1.3 à 14:25 a introduit une nouvelle fonctionnalité de recherche qui a activé cette requête défaillante.",
              "system_reaction": "PostgreSQL a verrouillé la table 'urls' en mode EXCLUSIVE, empêchant toute nouvelle connexion et bloquant toutes les opérations de lecture/écriture.",
              "non_idempotent_operation": "La requête de recherche n'était pas idempotente car elle créait des verrous de table persistants qui ne se libéraient pas automatiquement en cas d'échec.",
              "missing_protections": "Absence de timeout sur les requêtes SQL, pas de circuit breaker sur la base de données, monitoring insuffisant des performances de requêtes.",
              "late_detection": "Le monitoring ne couvrait pas les métriques de base de données (connexions actives, verrous, temps de requête), et les alertes étaient configurées uniquement sur les métriques applicatives.",
              "incident_manifestation": "L'incident s'est concrétisé lorsque le premier utilisateur a tenté d'utiliser la nouvelle fonctionnalité de recherche à 14:30, déclenchant la requête problématique."
            },
            "timeline": [
              {
                "time": "14:25",
                "title": "Déploiement de la version 2.1.3",
                "description": "Déploiement réussi de la nouvelle version avec fonctionnalité de recherche d'URLs"
              },
              {
                "time": "14:30",
                "title": "Première utilisation de la recherche",
                "description": "Un utilisateur utilise la nouvelle fonctionnalité de recherche, déclenchant la requête SQL problématique"
              },
              {
                "time": "14:32",
                "title": "Détection de l'incident",
                "description": "Alertes Prometheus déclenchées sur le taux d'erreur HTTP 500 > 95%"
              },
              {
                "time": "14:35",
                "title": "Mobilisation de l'équipe",
                "description": "Équipe SRE et Engineering mobilisées, début de l'investigation"
              },
              {
                "time": "15:00",
                "title": "Identification de la cause",
                "description": "Découverte du verrouillage de table PostgreSQL et de la requête SQL défaillante"
              },
              {
                "time": "15:15",
                "title": "Tentative de mitigation",
                "description": "Tentative de redémarrage du service application (échec - verrouillage persistant)"
              },
              {
                "time": "15:45",
                "title": "Redémarrage forcé de PostgreSQL",
                "description": "Redémarrage de la base de données pour libérer les verrous"
              },
              {
                "time": "16:00",
                "title": "Rollback de l'application",
                "description": "Retour à la version 2.1.2 stable"
              },
              {
                "time": "16:30",
                "title": "Stabilisation",
                "description": "Service partiellement restauré, monitoring des métriques"
              },
              {
                "time": "17:00",
                "title": "Résolution complète",
                "description": "Service entièrement opérationnel, validation des métriques de performance"
              }
            ],
            "lessons_learned": {
              "things_that_went_well": [
                "Les mécanismes de monitoring Prometheus ont détecté l'incident en 2 minutes",
                "La communication entre les équipes a été efficace via Slack et les canaux d'urgence",
                "Le processus de rollback automatisé a fonctionné correctement",
                "La base de données a bien récupéré après le redémarrage sans perte de données"
              ],
              "things_that_went_poorly": {
                "outage": [
                  "Absence de monitoring des métriques de base de données (connexions, verrous, temps de requête)",
                  "La requête SQL n'a pas été testée en charge avant le déploiement",
                  "Pas de circuit breaker sur les connexions de base de données",
                  "Les timeouts SQL n'étaient pas configurés correctement"
                ],
                "recovery": [
                  "Le redémarrage de l'application seul n'a pas résolu le problème (verrouillage persistant)",
                  "L'identification de la cause a pris 30 minutes faute de monitoring approprié",
                  "Pas de procédure documentée pour les incidents de base de données",
                  "La communication externe aux utilisateurs a été tardive (1h après le début)"
                ]
              },
              "where_we_got_lucky": [
                "La base de données a récupéré sans corruption après le redémarrage forcé",
                "Aucune donnée n'a été perdue malgré l'incident prolongé",
                "Les sauvegardes automatiques étaient à jour et fonctionnelles"
              ]
            },
            "action_items": [
              {
                "description": "Implémenter un monitoring complet des métriques PostgreSQL (connexions, verrous, temps de requête)",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe SRE",
                "tracking_bug": "SRE-123"
              },
              {
                "description": "Ajouter des tests de charge pour toutes les nouvelles requêtes SQL",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe Engineering",
                "tracking_bug": "ENG-456"
              },
              {
                "description": "Configurer des timeouts appropriés sur toutes les requêtes SQL",
                "type": "prevent",
                "priority": "P1",
                "owner": "Équipe Engineering",
                "tracking_bug": "ENG-457"
              },
              {
                "description": "Implémenter un circuit breaker pour les connexions de base de données",
                "type": "prevent",
                "priority": "P1",
                "owner": "Équipe SRE",
                "tracking_bug": "SRE-124"
              },
              {
                "description": "Documenter la procédure de résolution des incidents de base de données",
                "type": "remediate",
                "priority": "P1",
                "owner": "Équipe SRE",
                "tracking_bug": "SRE-125"
              },
              {
                "description": "Améliorer la communication externe en cas d'incident (page de statut, notifications)",
                "type": "remediate",
                "priority": "P2",
                "owner": "Équipe Product",
                "tracking_bug": "PROD-789"
              }
            ],
            "glossary": {
              "HEC": "HTTP Event Collector de Splunk, utilisé pour l'ingestion des logs",
              "OTLP": "OpenTelemetry Protocol, protocole standard pour la collecte de métriques et traces",
              "Circuit Breaker": "Pattern de conception qui empêche les appels vers un service défaillant",
              "Rollback": "Retour à une version précédente stable de l'application",
              "Verrouillage de table": "Mécanisme de PostgreSQL qui bloque l'accès à une table pour maintenir la cohérence des données"
            },
            "appendix": "Données complémentaires : Logs PostgreSQL détaillés, métriques Prometheus sur la période d'incident, captures d'écran des dashboards de monitoring, et analyse des performances de la requête problématique."
          }
          EOF
          
          # Changer vers le répertoire /app et démarrer l'application
          cd /app
          python app.py
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: postmortem-flask-service
  labels:
    app: postmortem-flask
spec:
  selector:
    app: postmortem-flask
  ports:
  - port: 80
    targetPort: 5000
    nodePort: 30001
  type: NodePort
