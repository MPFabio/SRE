apiVersion: apps/v1
kind: Deployment
metadata:
  name: postmortem-flask
  labels:
    app: postmortem-flask
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postmortem-flask
  template:
    metadata:
      labels:
        app: postmortem-flask
    spec:
      containers:
      - name: postmortem-flask
        image: python:3.11-slim
        ports:
        - containerPort: 5000
        command: ["/bin/bash"]
        args:
        - -c
        - |
          # Installer les dépendances
          pip install --no-cache-dir flask markdown
          
          # Créer les répertoires
          mkdir -p /app/data/postmortems
          mkdir -p /app/templates
          
          # Copier l'application Flask (code exact de l'app locale)
          cat > /app/app.py << 'EOF'
          #!/usr/bin/env python3
          """
          Application Flask pour la présentation des post-mortems SRE
          Interface web pour visualiser les post-mortems avec un format structuré
          """

          from flask import Flask, render_template, jsonify, request
          import json
          import os
          from datetime import datetime
          import logging

          # Configuration du logging
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)

          app = Flask(__name__)

          # Configuration
          POSTMORTEM_DIR = "data/postmortems"
          TEMPLATE_DIR = "templates"

          def load_postmortem(postmortem_id):
              """Charge un post-mortem depuis le fichier JSON"""
              try:
                  file_path = os.path.join(POSTMORTEM_DIR, f"{postmortem_id}.json")
                  with open(file_path, 'r', encoding='utf-8') as f:
                      return json.load(f)
              except FileNotFoundError:
                  logger.error(f"Post-mortem {postmortem_id} non trouvé")
                  return None
              except json.JSONDecodeError as e:
                  logger.error(f"Erreur de parsing JSON pour {postmortem_id}: {e}")
                  return None

          def list_postmortems():
              """Liste tous les post-mortems disponibles"""
              postmortems = []
              if os.path.exists(POSTMORTEM_DIR):
                  for filename in os.listdir(POSTMORTEM_DIR):
                      if filename.endswith('.json'):
                          postmortem_id = filename[:-5]  # Enlever .json
                          try:
                              postmortem = load_postmortem(postmortem_id)
                              if postmortem:
                                  postmortems.append({
                                      'id': postmortem_id,
                                      'title': postmortem.get('title', 'Sans titre'),
                                      'incident_date': postmortem.get('incident_date', ''),
                                      'status': postmortem.get('status', 'Brouillon'),
                                      'published': postmortem.get('published', ''),
                                      'owner': postmortem.get('owner', ''),
                                      'problem_summary': postmortem.get('problem_summary', {}),
                                      'executive_summary': postmortem.get('executive_summary', {})
                                  })
                          except Exception as e:
                              logger.error(f"Erreur lors du chargement de {postmortem_id}: {e}")
              return sorted(postmortems, key=lambda x: x.get('incident_date', ''), reverse=True)

          @app.route('/')
          def index():
              """Page d'accueil avec la liste des post-mortems"""
              postmortems = list_postmortems()
              return render_template('index.html', postmortems=postmortems)

          @app.route('/postmortem/<postmortem_id>')
          def view_postmortem(postmortem_id):
              """Page de visualisation d'un post-mortem spécifique"""
              postmortem = load_postmortem(postmortem_id)
              if not postmortem:
                  return render_template('error.html', 
                                       message=f"Post-mortem '{postmortem_id}' non trouvé"), 404
              
              return render_template('postmortem.html', postmortem=postmortem)

          @app.route('/api/postmortems')
          def api_list_postmortems():
              """API pour lister les post-mortems"""
              postmortems = list_postmortems()
              return jsonify(postmortems)

          @app.route('/api/postmortem/<postmortem_id>')
          def api_get_postmortem(postmortem_id):
              """API pour récupérer un post-mortem spécifique"""
              postmortem = load_postmortem(postmortem_id)
              if not postmortem:
                  return jsonify({'error': 'Post-mortem non trouvé'}), 404
              return jsonify(postmortem)

          @app.route('/create')
          def create_postmortem():
              """Page de création d'un nouveau post-mortem"""
              return render_template('create.html')

          @app.route('/api/create', methods=['POST'])
          def api_create_postmortem():
              """API pour créer un nouveau post-mortem"""
              try:
                  data = request.get_json()
                  
                  # Générer un ID unique basé sur le timestamp
                  postmortem_id = f"incident_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                  
                  # Ajouter des métadonnées
                  data['created_at'] = datetime.now().isoformat()
                  data['id'] = postmortem_id
                  
                  # Sauvegarder le fichier
                  os.makedirs(POSTMORTEM_DIR, exist_ok=True)
                  file_path = os.path.join(POSTMORTEM_DIR, f"{postmortem_id}.json")
                  
                  with open(file_path, 'w', encoding='utf-8') as f:
                      json.dump(data, f, indent=2, ensure_ascii=False)
                  
                  return jsonify({'success': True, 'id': postmortem_id})
              
              except Exception as e:
                  logger.error(f"Erreur lors de la création du post-mortem: {e}")
                  return jsonify({'error': str(e)}), 500

          @app.errorhandler(404)
          def not_found(error):
              return render_template('error.html', message="Page non trouvée"), 404

          @app.errorhandler(500)
          def internal_error(error):
              return render_template('error.html', message="Erreur interne du serveur"), 500

          if __name__ == '__main__':
              # Créer les répertoires nécessaires
              os.makedirs(POSTMORTEM_DIR, exist_ok=True)
              os.makedirs(TEMPLATE_DIR, exist_ok=True)
              
              # Démarrer l'application
              app.run(host='0.0.0.0', port=5000, debug=False)
          EOF
          
          # Copier les templates (base.html)
          cat > /app/templates/base.html << 'EOF'
          <!DOCTYPE html>
          <html lang="fr">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>{% block title %}Post-Mortems SRE{% endblock %}</title>
              <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
              <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
              <style>
                  .navbar-brand { font-weight: bold; }
                  .card { margin-bottom: 1rem; }
                  .badge { font-size: 0.8em; }
                  .timeline-item { margin-bottom: 1rem; }
                  .action-item { margin-bottom: 0.5rem; }
              </style>
          </head>
          <body>
              <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
                  <div class="container">
                      <a class="navbar-brand" href="{{ url_for('index') }}">
                          <i class="fas fa-clipboard-list me-2"></i>Post-Mortems SRE
                      </a>
                      <div class="navbar-nav ms-auto">
                          <a class="nav-link" href="{{ url_for('index') }}">
                              <i class="fas fa-list me-1"></i>Liste
                          </a>
                          <a class="nav-link" href="{{ url_for('create_postmortem') }}">
                              <i class="fas fa-plus me-1"></i>Créer
                          </a>
                      </div>
                  </div>
              </nav>

              <main>
                  {% block content %}{% endblock %}
              </main>

              <footer class="bg-dark text-light py-3 mt-5">
                  <div class="container">
                      <div class="row">
                          <div class="col-md-6">
                              <h5>Post-Mortems SRE</h5>
                              <p class="mb-0">Interface de gestion et visualisation des post-mortems d'incidents.</p>
                          </div>
                          <div class="col-md-6 text-md-end">
                              <p class="mb-0">© 2024 Lab SRE. Tous droits réservés.</p>
                          </div>
                      </div>
                  </div>
              </footer>

              <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
          </body>
          </html>
          EOF
          
          # Copier le template index.html (exact de l'app locale)
          cat > /app/templates/index.html << 'EOF'
          {% extends "base.html" %}

          {% block title %}Liste des Post-Mortems - SRE{% endblock %}

          {% block content %}
          <div class="container mt-4">
              <!-- En-tête -->
              <div class="row mb-4">
                  <div class="col-12">
                      <h1 class="display-4 text-center mb-3">
                          <i class="fas fa-clipboard-list text-primary me-3"></i>
                          Post-Mortems SRE
                      </h1>
                      <p class="lead text-center text-muted">
                          Gestion et visualisation des post-mortems d'incidents
                      </p>
                  </div>
              </div>

              <!-- Statistiques -->
              <div class="row mb-4">
                  <div class="col-md-3">
                      <div class="card text-center">
                          <div class="card-body">
                              <h3 class="text-primary">{{ postmortems|length }}</h3>
                              <p class="text-muted">Total Post-Mortems</p>
                          </div>
                      </div>
                  </div>
                  <div class="col-md-3">
                      <div class="card text-center">
                          <div class="card-body">
                              <h3 class="text-success">{{ postmortems|selectattr('status', 'equalto', 'Final')|list|length }}</h3>
                              <p class="text-muted">Finalisés</p>
                          </div>
                      </div>
                  </div>
                  <div class="col-md-3">
                      <div class="card text-center">
                          <div class="card-body">
                              <h3 class="text-warning">{{ postmortems|selectattr('status', 'equalto', 'Brouillon')|list|length }}</h3>
                              <p class="text-muted">Brouillons</p>
                          </div>
                      </div>
                  </div>
                  <div class="col-md-3">
                      <div class="card text-center">
                          <div class="card-body">
                              <h3 class="text-info">{{ postmortems|selectattr('status', 'equalto', 'En cours de révision')|list|length }}</h3>
                              <p class="text-muted">En Révision</p>
                          </div>
                      </div>
                  </div>
              </div>

              <!-- Bouton de création -->
              <div class="row mb-4">
                  <div class="col-12 text-center">
                      <a href="{{ url_for('create_postmortem') }}" class="btn btn-primary btn-lg">
                          <i class="fas fa-plus me-2"></i>Nouveau Post-Mortem
                      </a>
                  </div>
              </div>

              <!-- Liste des post-mortems -->
              <div class="row">
                  {% for postmortem in postmortems %}
                  <div class="col-md-4 mb-4">
                      <div class="card h-100">
                          <div class="card-header d-flex justify-content-between align-items-center">
                              <h6 class="mb-0">{{ postmortem.owner }}</h6>
                              <span class="badge bg-success">{{ postmortem.status }}</span>
                          </div>
                          <div class="card-body">
                              <h5 class="card-title">{{ postmortem.title }}</h5>
                              <p class="card-text">
                                  <small class="text-muted">
                                      <i class="fas fa-calendar me-1"></i>
                                      {{ postmortem.incident_date[:10] if postmortem.incident_date else 'Date inconnue' }}
                                  </small>
                              </p>
                              {% if postmortem.problem_summary.duration %}
                              <p class="card-text">
                                  <small class="text-muted">
                                      <i class="fas fa-clock me-1"></i>
                                      Durée: {{ postmortem.problem_summary.duration }}
                                  </small>
                              </p>
                              {% endif %}
                              {% if postmortem.executive_summary.impact %}
                              <p class="card-text">
                                  <small class="text-muted">{{ postmortem.executive_summary.impact[:100] }}...</small>
                              </p>
                              {% endif %}
                          </div>
                          <div class="card-footer">
                              <a href="{{ url_for('view_postmortem', postmortem_id=postmortem.id) }}" class="btn btn-primary btn-sm">
                                  <i class="fas fa-eye me-1"></i>Voir
                              </a>
                          </div>
                      </div>
                  </div>
                  {% endfor %}
              </div>

              {% if not postmortems %}
              <div class="row">
                  <div class="col-12 text-center">
                      <div class="alert alert-info">
                          <i class="fas fa-info-circle me-2"></i>
                          Aucun post-mortem trouvé. 
                          <a href="{{ url_for('create_postmortem') }}" class="alert-link">Créer le premier post-mortem</a>.
                      </div>
                  </div>
              </div>
              {% endif %}
          </div>
          {% endblock %}
          EOF
          
          # Copier les autres templates nécessaires
          cat > /app/templates/error.html << 'EOF'
          {% extends "base.html" %}

          {% block title %}Erreur - Post-Mortems SRE{% endblock %}

          {% block content %}
          <div class="container mt-5">
              <div class="row justify-content-center">
                  <div class="col-md-6">
                      <div class="alert alert-danger text-center">
                          <i class="fas fa-exclamation-triangle fa-3x mb-3"></i>
                          <h4>Erreur</h4>
                          <p>{{ message }}</p>
                          <a href="{{ url_for('index') }}" class="btn btn-primary">
                              <i class="fas fa-home me-1"></i>Retour à l'accueil
                          </a>
                      </div>
                  </div>
              </div>
          </div>
          {% endblock %}
          EOF
          
          cat > /app/templates/postmortem.html << 'EOF'
          {% extends "base.html" %}

          {% block title %}{{ postmortem.title }} - Post-Mortems SRE{% endblock %}

          {% block content %}
          <div class="container mt-4">
              <div class="row">
                  <div class="col-12">
                      <div class="d-flex justify-content-between align-items-center mb-4">
                          <h1>{{ postmortem.title }}</h1>
                          <span class="badge bg-success fs-6">{{ postmortem.status }}</span>
                      </div>
                      
                      <div class="card">
                          <div class="card-header">
                              <h5 class="mb-0">Informations générales</h5>
                          </div>
                          <div class="card-body">
                              <div class="row">
                                  <div class="col-md-6">
                                      <p><strong>Propriétaire:</strong> {{ postmortem.owner }}</p>
                                      <p><strong>Date de l'incident:</strong> {{ postmortem.incident_date }}</p>
                                  </div>
                                  <div class="col-md-6">
                                      <p><strong>Publié:</strong> {{ postmortem.published }}</p>
                                      <p><strong>Partagé avec:</strong> {{ postmortem.shared_with }}</p>
                                  </div>
                              </div>
                          </div>
                      </div>
                      
                      {% if postmortem.executive_summary %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Résumé exécutif</h5>
                          </div>
                          <div class="card-body">
                              <p><strong>Impact:</strong> {{ postmortem.executive_summary.impact }}</p>
                              <p><strong>Cause racine:</strong> {{ postmortem.executive_summary.root_cause }}</p>
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.problem_summary %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Résumé du problème</h5>
                          </div>
                          <div class="card-body">
                              <div class="row">
                                  <div class="col-md-6">
                                      <p><strong>Durée:</strong> {{ postmortem.problem_summary.duration }}</p>
                                      <p><strong>Début:</strong> {{ postmortem.problem_summary.start_time }}</p>
                                  </div>
                                  <div class="col-md-6">
                                      <p><strong>Fin:</strong> {{ postmortem.problem_summary.end_time }}</p>
                                      <p><strong>Produits affectés:</strong> {{ postmortem.problem_summary.products_affected }}</p>
                                  </div>
                              </div>
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.impact %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Impact détaillé</h5>
                          </div>
                          <div class="card-body">
                              {% if postmortem.impact.user_impact %}
                              <h6>Impact utilisateur</h6>
                              <p><strong>Requêtes perdues:</strong> {{ postmortem.impact.user_impact.requests_lost }}</p>
                              <p><strong>Source des données:</strong> {{ postmortem.impact.user_impact.data_source }}</p>
                              {% endif %}
                              
                              {% if postmortem.impact.revenue_impact %}
                              <h6>Impact financier</h6>
                              <p><strong>Perte de revenus:</strong> {{ postmortem.impact.revenue_impact.revenue_loss }}</p>
                              <p><strong>Période:</strong> {{ postmortem.impact.revenue_impact.revenue_period }}</p>
                              {% endif %}
                              
                              {% if postmortem.impact.team_impact %}
                              <h6>Impact équipe</h6>
                              <p><strong>Heures équipe:</strong> {{ postmortem.impact.team_impact.team_hours }}</p>
                              <p><strong>Support client:</strong> {{ postmortem.impact.team_impact.customer_support }}</p>
                              {% endif %}
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.root_causes %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Causes racines</h5>
                          </div>
                          <div class="card-body">
                              <p><strong>Cause technique:</strong> {{ postmortem.root_causes.technical_cause }}</p>
                              <p><strong>Déclencheur:</strong> {{ postmortem.root_causes.trigger }}</p>
                              <p><strong>Réaction système:</strong> {{ postmortem.root_causes.system_reaction }}</p>
                              <p><strong>Protections manquantes:</strong> {{ postmortem.root_causes.missing_protections }}</p>
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.timeline %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Timeline de l'incident</h5>
                          </div>
                          <div class="card-body">
                              {% for event in postmortem.timeline %}
                              <div class="timeline-item">
                                  <div class="d-flex">
                                      <div class="me-3">
                                          <span class="badge bg-primary">{{ event.time }}</span>
                                      </div>
                                      <div>
                                          <h6 class="mb-1">{{ event.title }}</h6>
                                          <p class="mb-0 text-muted">{{ event.description }}</p>
                                      </div>
                                  </div>
                              </div>
                              {% endfor %}
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.lessons_learned %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Leçons apprises</h5>
                          </div>
                          <div class="card-body">
                              {% if postmortem.lessons_learned.things_that_went_well %}
                              <h6>Ce qui s'est bien passé</h6>
                              <ul>
                                  {% for item in postmortem.lessons_learned.things_that_went_well %}
                                  <li>{{ item }}</li>
                                  {% endfor %}
                              </ul>
                              {% endif %}
                              
                              {% if postmortem.lessons_learned.things_that_went_poorly %}
                              <h6>Ce qui s'est mal passé</h6>
                              {% if postmortem.lessons_learned.things_that_went_poorly.outage %}
                              <p><strong>Pendant la panne:</strong></p>
                              <ul>
                                  {% for item in postmortem.lessons_learned.things_that_went_poorly.outage %}
                                  <li>{{ item }}</li>
                                  {% endfor %}
                              </ul>
                              {% endif %}
                              {% if postmortem.lessons_learned.things_that_went_poorly.recovery %}
                              <p><strong>Pendant la récupération:</strong></p>
                              <ul>
                                  {% for item in postmortem.lessons_learned.things_that_went_poorly.recovery %}
                                  <li>{{ item }}</li>
                                  {% endfor %}
                              </ul>
                              {% endif %}
                              {% endif %}
                              
                              {% if postmortem.lessons_learned.where_we_got_lucky %}
                              <h6>Où nous avons eu de la chance</h6>
                              <ul>
                                  {% for item in postmortem.lessons_learned.where_we_got_lucky %}
                                  <li>{{ item }}</li>
                                  {% endfor %}
                              </ul>
                              {% endif %}
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.action_items %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Actions à suivre</h5>
                          </div>
                          <div class="card-body">
                              {% for action in postmortem.action_items %}
                              <div class="action-item">
                                  <div class="d-flex justify-content-between align-items-start">
                                      <div class="flex-grow-1">
                                          <p class="mb-1"><strong>{{ action.description }}</strong></p>
                                          <small class="text-muted">
                                              Type: {{ action.type }} | 
                                              Priorité: {{ action.priority }} | 
                                              Responsable: {{ action.owner }}
                                          </small>
                                      </div>
                                      <span class="badge bg-secondary">{{ action.tracking_bug }}</span>
                                  </div>
                              </div>
                              {% endfor %}
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.glossary %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Glossaire</h5>
                          </div>
                          <div class="card-body">
                              {% for term, definition in postmortem.glossary.items() %}
                              <p><strong>{{ term }}:</strong> {{ definition }}</p>
                              {% endfor %}
                          </div>
                      </div>
                      {% endif %}
                      
                      {% if postmortem.appendix %}
                      <div class="card mt-3">
                          <div class="card-header">
                              <h5 class="mb-0">Annexe</h5>
                          </div>
                          <div class="card-body">
                              <p>{{ postmortem.appendix }}</p>
                          </div>
                      </div>
                      {% endif %}
                  </div>
              </div>
          </div>
          {% endblock %}
          EOF
          
          cat > /app/templates/create.html << 'EOF'
          {% extends "base.html" %}

          {% block title %}Créer un Post-Mortem - SRE{% endblock %}

          {% block content %}
          <div class="container mt-4">
              <div class="row">
                  <div class="col-12">
                      <h1>Créer un nouveau Post-Mortem</h1>
                      <p class="text-muted">Formulaire de création d'un post-mortem d'incident</p>
                  </div>
              </div>
              
              <div class="row">
                  <div class="col-md-8">
                      <div class="card">
                          <div class="card-body">
                              <form id="postmortemForm">
                                  <div class="mb-3">
                                      <label for="title" class="form-label">Titre *</label>
                                      <input type="text" class="form-control" id="title" name="title" required>
                                  </div>
                                  
                                  <div class="mb-3">
                                      <label for="owner" class="form-label">Propriétaire *</label>
                                      <input type="text" class="form-control" id="owner" name="owner" required>
                                  </div>
                                  
                                  <div class="mb-3">
                                      <label for="incident_date" class="form-label">Date de l'incident *</label>
                                      <input type="datetime-local" class="form-control" id="incident_date" name="incident_date" required>
                                  </div>
                                  
                                  <div class="mb-3">
                                      <label for="status" class="form-label">Statut</label>
                                      <select class="form-select" id="status" name="status">
                                          <option value="Brouillon">Brouillon</option>
                                          <option value="En cours de révision">En cours de révision</option>
                                          <option value="Final">Final</option>
                                      </select>
                                  </div>
                                  
                                  <button type="submit" class="btn btn-primary">
                                      <i class="fas fa-save me-1"></i>Créer le Post-Mortem
                                  </button>
                              </form>
                          </div>
                      </div>
                  </div>
              </div>
          </div>

          <script>
          document.getElementById('postmortemForm').addEventListener('submit', async function(e) {
              e.preventDefault();
              
              const formData = new FormData(this);
              const data = Object.fromEntries(formData.entries());
              
              try {
                  const response = await fetch('/api/create', {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                      },
                      body: JSON.stringify(data)
                  });
                  
                  const result = await response.json();
                  
                  if (result.success) {
                      alert('Post-mortem créé avec succès !');
                      window.location.href = '/';
                  } else {
                      alert('Erreur lors de la création: ' + result.error);
                  }
              } catch (error) {
                  alert('Erreur réseau: ' + error.message);
              }
          });
          </script>
          {% endblock %}
          EOF
          
          # Ajouter les post-mortems pré-créés COMPLETS
          cat > /app/data/postmortems/incident_20241210_163000.json << 'EOF'
          {
            "id": "incident_20241210_163000",
            "title": "Panne du service d'authentification - Indisponibilité des connexions utilisateurs",
            "owner": "Équipe Security",
            "shared_with": "Équipes Engineering, Product, Support, Legal",
            "status": "Final",
            "incident_date": "2024-12-10T16:30:00Z",
            "published": "2024-12-11",
            "created_at": "2024-12-10T18:45:00Z",
            "executive_summary": {
              "impact": "L'incident a rendu impossible toute connexion utilisateur pendant 3h15, affectant 25 000 utilisateurs actifs et bloquant l'accès à tous les services nécessitant une authentification.",
              "root_cause": "Une panne du service d'authentification OAuth2 due à l'expiration d'un certificat SSL critique qui n'était pas surveillé."
            },
            "problem_summary": {
              "duration": "3h15",
              "start_time": "2024-12-10T16:30:00Z",
              "end_time": "2024-12-10T19:45:00Z",
              "residual_effects": "2024-12-10T20:00:00Z - Latence élevée pendant 15 minutes supplémentaires",
              "products_affected": "Service d'authentification OAuth2, API Gateway, Applications web et mobile",
              "percentage_affected": "100% des utilisateurs nécessitant une authentification",
              "user_impact": "25 000 utilisateurs actifs ont été bloqués, impossible de se connecter à tous les services",
              "revenue_impact": "Perte estimée de 8 500€ due à l'impossibilité d'accéder aux services payants et aux conversions",
              "detection": "Alertes automatiques sur le taux d'erreur d'authentification > 99%",
              "resolution": "Renouvellement du certificat SSL, redémarrage du service d'authentification, et validation de tous les flux d'authentification."
            },
            "impact": {
              "user_impact": {
                "requests_lost": "75 000 tentatives de connexion échouées",
                "data_source": "Logs d'authentification et métriques de l'API Gateway",
                "additional_symptoms": "Erreurs 500 sur toutes les tentatives de connexion, timeouts sur les requêtes d'authentification, saturation des logs d'erreur"
              },
              "revenue_impact": {
                "revenue_loss": "8 500€, principalement sur les services payants et les conversions",
                "revenue_period": "16:30 - 19:45 (3h15)",
                "indirect_impacts": "Perte de confiance des utilisateurs, 12 annulations d'abonnements, impact sur la réputation de sécurité"
              },
              "team_impact": {
                "team_hours": "12 heures à la résolution, investigation et communication",
                "customer_support": "Support client avec 340 tickets créés et 89 appels téléphoniques",
                "secondary_effects": "Surcharge du support client, stress des équipes de sécurité, impact sur la réputation"
              }
            },
            "root_causes": {
              "technical_cause": "Le certificat SSL du service d'authentification OAuth2 a expiré à 16:30, rendant impossible la validation des tokens et bloquant tous les flux d'authentification.",
              "trigger": "L'expiration automatique du certificat SSL à 16:30 a immédiatement cassé toutes les communications sécurisées du service d'authentification.",
              "system_reaction": "Le service d'authentification a commencé à rejeter toutes les requêtes avec des erreurs SSL, empêchant la validation des tokens et bloquant l'accès aux services.",
              "non_idempotent_operation": "Le renouvellement de certificat n'était pas automatisé et nécessitait une intervention manuelle avec redémarrage du service.",
              "missing_protections": "Absence de monitoring des certificats SSL, pas d'alerte avant expiration, absence de renouvellement automatique, pas de certificats de backup.",
              "late_detection": "Aucune surveillance des certificats SSL n'était en place, et les équipes comptaient sur les notifications manuelles du fournisseur de certificats."
            },
            "timeline": [
              {
                "time": "16:30",
                "title": "Expiration du certificat SSL",
                "description": "Le certificat SSL du service d'authentification expire automatiquement"
              },
              {
                "time": "16:32",
                "title": "Détection automatique de l'incident",
                "description": "Alertes déclenchées sur le taux d'erreur d'authentification > 99%"
              },
              {
                "time": "16:35",
                "title": "Mobilisation de l'équipe Security",
                "description": "Équipe Security et Engineering mobilisées, début de l'investigation"
              },
              {
                "time": "16:45",
                "title": "Identification de la cause",
                "description": "Découverte de l'expiration du certificat SSL et des erreurs de validation"
              },
              {
                "time": "17:00",
                "title": "Communication externe",
                "description": "Publication d'un message de statut et notification des utilisateurs"
              },
              {
                "time": "17:30",
                "title": "Début du renouvellement",
                "description": "Début du processus de renouvellement du certificat SSL"
              },
              {
                "time": "19:00",
                "title": "Installation du nouveau certificat",
                "description": "Installation et configuration du nouveau certificat SSL"
              },
              {
                "time": "19:30",
                "title": "Redémarrage du service",
                "description": "Redémarrage du service d'authentification avec le nouveau certificat"
              },
              {
                "time": "19:45",
                "title": "Validation et résolution",
                "description": "Test de tous les flux d'authentification et validation du fonctionnement"
              }
            ],
            "lessons_learned": {
              "things_that_went_well": [
                "Les alertes automatiques ont détecté l'incident en 2 minutes",
                "La communication avec les utilisateurs a été rapide et claire",
                "Le processus de renouvellement de certificat était documenté",
                "Aucune donnée utilisateur n'a été compromise"
              ],
              "things_that_went_poorly": {
                "outage": [
                  "Absence totale de monitoring des certificats SSL",
                  "Pas d'alerte avant expiration des certificats",
                  "Absence de renouvellement automatique",
                  "Pas de certificats de backup ou de rotation"
                ],
                "recovery": [
                  "Le processus de renouvellement a pris 2h30 (trop long)",
                  "Pas de procédure d'urgence pour les certificats expirés",
                  "Communication tardive avec les utilisateurs (30 minutes)",
                  "Absence de tests automatisés des flux d'authentification"
                ]
              },
              "where_we_got_lucky": [
                "Le certificat a expiré en journée (pas la nuit)",
                "Aucune tentative d'intrusion pendant la panne",
                "Les données utilisateur n'ont pas été compromises",
                "Le fournisseur de certificats a répondu rapidement"
              ]
            },
            "action_items": [
              {
                "description": "Implémenter un monitoring automatique des certificats SSL avec alertes 30 jours avant expiration",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe Security",
                "tracking_bug": "SEC-401"
              },
              {
                "description": "Configurer le renouvellement automatique des certificats SSL",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe Security",
                "tracking_bug": "SEC-402"
              },
              {
                "description": "Mettre en place une rotation automatique des certificats",
                "type": "prevent",
                "priority": "P1",
                "owner": "Équipe Security",
                "tracking_bug": "SEC-403"
              },
              {
                "description": "Créer des procédures d'urgence pour les incidents de certificats",
                "type": "remediate",
                "priority": "P1",
                "owner": "Équipe Security",
                "tracking_bug": "SEC-404"
              },
              {
                "description": "Améliorer la communication automatique en cas d'incident de sécurité",
                "type": "remediate",
                "priority": "P2",
                "owner": "Équipe Product",
                "tracking_bug": "PROD-501"
              }
            ],
            "glossary": {
              "OAuth2": "Protocole d'autorisation standard pour l'authentification et l'autorisation",
              "SSL": "Secure Sockets Layer, protocole de sécurité pour les communications chiffrées",
              "Token": "Jeton d'authentification utilisé pour valider l'identité d'un utilisateur",
              "API Gateway": "Point d'entrée unique pour toutes les requêtes API",
              "Certificat SSL": "Certificat numérique utilisé pour sécuriser les communications HTTPS"
            },
            "appendix": "Logs détaillés des erreurs SSL, métriques de l'API Gateway, captures d'écran des erreurs d'authentification, et documentation du processus de renouvellement de certificat."
          }
          EOF
          
          # Post-mortem 2 complet
          cat > /app/data/postmortems/incident_20241215_091500.json << 'EOF'
          {
            "id": "incident_20241215_091500",
            "title": "Panne de la base de données principale - Perte de données temporaire",
            "owner": "Équipe Database",
            "shared_with": "Équipes Engineering, Product, Support",
            "status": "Final",
            "incident_date": "2024-12-15T09:15:00Z",
            "published": "2024-12-16",
            "created_at": "2024-12-15T11:30:00Z",
            "executive_summary": {
              "impact": "Panne de la base de données principale pendant 2h45, causant une perte temporaire de données et des erreurs de synchronisation.",
              "root_cause": "Défaillance matérielle du disque principal de la base de données avec basculement défaillant vers le réplica."
            },
            "problem_summary": {
              "duration": "2h45",
              "start_time": "2024-12-15T09:15:00Z",
              "end_time": "2024-12-15T12:00:00Z",
              "residual_effects": "2024-12-15T12:30:00Z - Synchronisation des données pendant 30 minutes",
              "products_affected": "Base de données principale, API de données, Tableaux de bord",
              "percentage_affected": "85% des fonctionnalités nécessitant des données",
              "user_impact": "15 000 utilisateurs affectés, données temporairement indisponibles",
              "revenue_impact": "Perte estimée de 5 200€ due à l'indisponibilité des services",
              "detection": "Alertes automatiques sur la connectivité de la base de données",
              "resolution": "Remplacement du disque défaillant, restauration depuis les sauvegardes, et validation de l'intégrité des données."
            },
            "impact": {
              "user_impact": {
                "requests_lost": "45 000 requêtes API échouées",
                "data_source": "Logs de la base de données et métriques d'application",
                "additional_symptoms": "Timeouts sur les requêtes de base de données, erreurs de connexion, saturation des pools de connexions"
              },
              "revenue_impact": {
                "revenue_loss": "5 200€, principalement sur les transactions et les rapports",
                "revenue_period": "09:15 - 12:00 (2h45)",
                "indirect_impacts": "Perte de données temporaire, 8 annulations d'abonnements, impact sur la confiance des utilisateurs"
              },
              "team_impact": {
                "team_hours": "18 heures à la résolution, investigation et récupération",
                "customer_support": "Support client avec 180 tickets créés et 45 appels téléphoniques",
                "secondary_effects": "Surcharge des équipes de base de données, stress des équipes de développement, impact sur la réputation"
              }
            },
            "root_causes": {
              "technical_cause": "Défaillance matérielle du disque principal de la base de données PostgreSQL, causant une perte de connectivité et empêchant l'accès aux données.",
              "trigger": "Le disque principal a commencé à générer des erreurs de lecture/écriture à 09:15, rendant la base de données inaccessible.",
              "system_reaction": "Le système de basculement automatique vers le réplica a échoué en raison d'une configuration incorrecte, laissant la base de données principale inaccessible.",
              "non_idempotent_operation": "Le processus de basculement n'était pas testé régulièrement et contenait des erreurs de configuration.",
              "missing_protections": "Absence de monitoring des disques, pas d'alerte sur les erreurs de disque, configuration de basculement incorrecte, pas de tests de récupération réguliers.",
              "late_detection": "Les alertes sur les erreurs de disque n'étaient pas configurées, et l'équipe a découvert le problème seulement après les plaintes des utilisateurs."
            },
            "timeline": [
              {
                "time": "09:15",
                "title": "Défaillance du disque principal",
                "description": "Le disque principal de la base de données commence à générer des erreurs de lecture/écriture"
              },
              {
                "time": "09:20",
                "title": "Premières plaintes utilisateurs",
                "description": "Les utilisateurs commencent à signaler des erreurs et des timeouts"
              },
              {
                "time": "09:25",
                "title": "Mobilisation de l'équipe Database",
                "description": "Équipe Database et Engineering mobilisées, début de l'investigation"
              },
              {
                "time": "09:35",
                "title": "Identification de la cause",
                "description": "Découverte de la défaillance du disque et de l'échec du basculement automatique"
              },
              {
                "time": "09:45",
                "title": "Communication externe",
                "description": "Publication d'un message de statut et notification des utilisateurs"
              },
              {
                "time": "10:00",
                "title": "Début de la récupération",
                "description": "Début du processus de remplacement du disque et de restauration des données"
              },
              {
                "time": "11:30",
                "title": "Installation du nouveau disque",
                "description": "Remplacement du disque défaillant et installation du nouveau disque"
              },
              {
                "time": "11:45",
                "title": "Restauration des données",
                "description": "Restauration des données depuis les sauvegardes et validation de l'intégrité"
              },
              {
                "time": "12:00",
                "title": "Validation et résolution",
                "description": "Test de tous les flux de données et validation du fonctionnement"
              }
            ],
            "lessons_learned": {
              "things_that_went_well": [
                "Les sauvegardes étaient à jour et complètes",
                "La communication avec les utilisateurs a été claire",
                "L'équipe a réagi rapidement une fois le problème identifié",
                "Aucune donnée critique n'a été définitivement perdue"
              ],
              "things_that_went_poorly": {
                "outage": [
                  "Absence de monitoring des disques",
                  "Configuration de basculement incorrecte",
                  "Pas d'alerte sur les erreurs de disque",
                  "Absence de tests de récupération réguliers"
                ],
                "recovery": [
                  "Le processus de basculement a échoué",
                  "Le remplacement du disque a pris 2h30 (trop long)",
                  "Communication tardive avec les utilisateurs (20 minutes)",
                  "Absence de procédures d'urgence documentées"
                ]
              },
              "where_we_got_lucky": [
                "Le disque a échoué en journée (pas la nuit)",
                "Les sauvegardes étaient récentes et complètes",
                "Aucune donnée critique n'a été corrompue",
                "L'équipe était disponible pour intervenir rapidement"
              ]
            },
            "action_items": [
              {
                "description": "Implémenter un monitoring automatique des disques avec alertes sur les erreurs",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe Database",
                "tracking_bug": "DB-501"
              },
              {
                "description": "Corriger la configuration de basculement automatique",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe Database",
                "tracking_bug": "DB-502"
              },
              {
                "description": "Mettre en place des tests de récupération mensuels",
                "type": "prevent",
                "priority": "P1",
                "owner": "Équipe Database",
                "tracking_bug": "DB-503"
              },
              {
                "description": "Créer des procédures d'urgence pour les pannes de base de données",
                "type": "remediate",
                "priority": "P1",
                "owner": "Équipe Database",
                "tracking_bug": "DB-504"
              },
              {
                "description": "Améliorer la communication automatique en cas d'incident de base de données",
                "type": "remediate",
                "priority": "P2",
                "owner": "Équipe Product",
                "tracking_bug": "PROD-502"
              }
            ],
            "glossary": {
              "PostgreSQL": "Système de gestion de base de données relationnelle open source",
              "Basculement": "Processus de transfert automatique vers un système de secours",
              "Réplica": "Copie de la base de données principale utilisée pour la redondance",
              "Pool de connexions": "Gestionnaire de connexions à la base de données pour optimiser les performances",
              "Sauvegarde": "Copie de sécurité des données pour la récupération en cas de perte"
            },
            "appendix": "Logs détaillés des erreurs de disque, métriques de performance de la base de données, captures d'écran des erreurs de connexion, et documentation du processus de restauration."
          }
          EOF
          
          # Post-mortem 3 complet
          cat > /app/data/postmortems/incident_20241222_143000.json << 'EOF'
          {
            "id": "incident_20241222_143000",
            "title": "Panne de l'API Gateway - Saturation des requêtes",
            "owner": "Équipe Infrastructure",
            "shared_with": "Équipes Engineering, Product, Support",
            "status": "Final",
            "incident_date": "2024-12-22T14:30:00Z",
            "published": "2024-12-23",
            "created_at": "2024-12-22T16:45:00Z",
            "executive_summary": {
              "impact": "Saturation de l'API Gateway pendant 1h30, causant des timeouts et des erreurs 503 sur toutes les requêtes API.",
              "root_cause": "Pointe de trafic inattendue due à une campagne marketing non communiquée, dépassant la capacité de l'API Gateway."
            },
            "problem_summary": {
              "duration": "1h30",
              "start_time": "2024-12-22T14:30:00Z",
              "end_time": "2024-12-22T16:00:00Z",
              "residual_effects": "2024-12-22T16:15:00Z - Latence élevée pendant 15 minutes supplémentaires",
              "products_affected": "API Gateway, Toutes les APIs, Applications mobiles",
              "percentage_affected": "90% des requêtes API",
              "user_impact": "18 000 utilisateurs affectés, timeouts sur les requêtes API",
              "revenue_impact": "Perte estimée de 3 800€ due aux erreurs de transaction",
              "detection": "Alertes automatiques sur le taux d'erreur de l'API Gateway > 95%",
              "resolution": "Mise à l'échelle automatique de l'API Gateway, optimisation des requêtes, et mise en place de limites de taux."
            },
            "impact": {
              "user_impact": {
                "requests_lost": "120 000 requêtes API échouées",
                "data_source": "Logs de l'API Gateway et métriques de performance",
                "additional_symptoms": "Timeouts sur toutes les requêtes API, erreurs 503, saturation des workers, latence élevée"
              },
              "revenue_impact": {
                "revenue_loss": "3 800€, principalement sur les transactions et les conversions",
                "revenue_period": "14:30 - 16:00 (1h30)",
                "indirect_impacts": "Perte de confiance des utilisateurs, 5 annulations d'abonnements, impact sur la réputation"
              },
              "team_impact": {
                "team_hours": "8 heures à la résolution, investigation et optimisation",
                "customer_support": "Support client avec 95 tickets créés et 23 appels téléphoniques",
                "secondary_effects": "Surcharge des équipes d'infrastructure, stress des équipes de développement, impact sur la réputation"
              }
            },
            "root_causes": {
              "technical_cause": "L'API Gateway a été saturée par une pointe de trafic inattendue due à une campagne marketing non communiquée, dépassant sa capacité de traitement.",
              "trigger": "Une campagne marketing a été lancée à 14:30 sans notification préalable, générant un trafic 5x supérieur à la normale.",
              "system_reaction": "L'API Gateway a commencé à rejeter les requêtes avec des erreurs 503 et des timeouts, empêchant l'accès aux services.",
              "non_idempotent_operation": "Le système de mise à l'échelle automatique n'était pas configuré pour gérer des pointes de trafic aussi importantes.",
              "missing_protections": "Absence de communication entre les équipes Marketing et Infrastructure, pas de monitoring du trafic marketing, absence de limites de taux, pas de tests de charge.",
              "late_detection": "L'équipe Infrastructure n'a pas été informée de la campagne marketing et a découvert le problème seulement après les alertes automatiques."
            },
            "timeline": [
              {
                "time": "14:30",
                "title": "Lancement de la campagne marketing",
                "description": "Campagne marketing lancée sans notification préalable de l'équipe Infrastructure"
              },
              {
                "time": "14:32",
                "title": "Détection automatique de l'incident",
                "description": "Alertes déclenchées sur le taux d'erreur de l'API Gateway > 95%"
              },
              {
                "time": "14:35",
                "title": "Mobilisation de l'équipe Infrastructure",
                "description": "Équipe Infrastructure et Engineering mobilisées, début de l'investigation"
              },
              {
                "time": "14:45",
                "title": "Identification de la cause",
                "description": "Découverte de la campagne marketing et de la saturation de l'API Gateway"
              },
              {
                "time": "14:50",
                "title": "Communication externe",
                "description": "Publication d'un message de statut et notification des utilisateurs"
              },
              {
                "time": "15:00",
                "title": "Début de la mise à l'échelle",
                "description": "Début du processus de mise à l'échelle automatique de l'API Gateway"
              },
              {
                "time": "15:30",
                "title": "Optimisation des requêtes",
                "description": "Mise en place de limites de taux et optimisation des requêtes"
              },
              {
                "time": "15:45",
                "title": "Stabilisation du système",
                "description": "L'API Gateway commence à traiter les requêtes normalement"
              },
              {
                "time": "16:00",
                "title": "Validation et résolution",
                "description": "Test de tous les flux API et validation du fonctionnement"
              }
            ],
            "lessons_learned": {
              "things_that_went_well": [
                "Les alertes automatiques ont détecté l'incident en 2 minutes",
                "La mise à l'échelle automatique a fonctionné une fois configurée",
                "La communication avec les utilisateurs a été rapide",
                "Aucune donnée utilisateur n'a été compromise"
              ],
              "things_that_went_poorly": {
                "outage": [
                  "Absence de communication entre Marketing et Infrastructure",
                  "Pas de monitoring du trafic marketing",
                  "Absence de limites de taux",
                  "Pas de tests de charge réguliers"
                ],
                "recovery": [
                  "Le processus de mise à l'échelle a pris 1h30 (trop long)",
                  "Pas de procédure d'urgence pour les pointes de trafic",
                  "Communication tardive avec les utilisateurs (20 minutes)",
                  "Absence de coordination entre les équipes"
                ]
              },
              "where_we_got_lucky": [
                "La campagne a été lancée en journée (pas la nuit)",
                "L'équipe Infrastructure était disponible",
                "Aucune donnée critique n'a été perdue",
                "Le système de mise à l'échelle a fini par fonctionner"
              ]
            },
            "action_items": [
              {
                "description": "Mettre en place un processus de communication obligatoire entre Marketing et Infrastructure",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe Infrastructure",
                "tracking_bug": "INFRA-601"
              },
              {
                "description": "Implémenter des limites de taux sur l'API Gateway",
                "type": "prevent",
                "priority": "P0",
                "owner": "Équipe Infrastructure",
                "tracking_bug": "INFRA-602"
              },
              {
                "description": "Mettre en place des tests de charge mensuels",
                "type": "prevent",
                "priority": "P1",
                "owner": "Équipe Infrastructure",
                "tracking_bug": "INFRA-603"
              },
              {
                "description": "Créer des procédures d'urgence pour les pointes de trafic",
                "type": "remediate",
                "priority": "P1",
                "owner": "Équipe Infrastructure",
                "tracking_bug": "INFRA-604"
              },
              {
                "description": "Améliorer la communication automatique en cas d'incident d'infrastructure",
                "type": "remediate",
                "priority": "P2",
                "owner": "Équipe Product",
                "tracking_bug": "PROD-503"
              }
            ],
            "glossary": {
              "API Gateway": "Point d'entrée unique pour toutes les requêtes API, gérant l'authentification, le routage et la limitation de taux",
              "Mise à l'échelle": "Processus d'ajout de ressources pour gérer l'augmentation du trafic",
              "Limite de taux": "Mécanisme de protection contre la surcharge en limitant le nombre de requêtes par utilisateur",
              "Timeout": "Délai d'attente dépassé, causant l'échec d'une requête",
              "Worker": "Processus de traitement des requêtes dans l'API Gateway"
            },
            "appendix": "Logs détaillés de l'API Gateway, métriques de performance, captures d'écran des erreurs 503, et documentation du processus de mise à l'échelle."
          }
          EOF
          
          # Changer vers le répertoire /app et démarrer l'application
          cd /app
          python app.py
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: postmortem-flask-service
  labels:
    app: postmortem-flask
spec:
  selector:
    app: postmortem-flask
  ports:
  - port: 80
    targetPort: 5000
    nodePort: 30001
  type: NodePort
